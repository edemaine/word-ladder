{createEffect, createResource, createSignal, For, Show} from 'solid-js'
{type LadderDAG, type LadderOptions, LadderSearch} from './ladder.civet'

wordList from '../data/wordlist.10000.txt'

export function App
  [start, setStart] := createSignal ''
  [goal, setGoal] := createSignal ''
  [options, setOptions] := createSignal<LadderOptions & {depth?: number}>
    swap: true
    insert: true
    delete: true
  ladderSearch .= new LadderSearch []
  [ladder, setLadder] := createSignal<string[] | null> []
  [DAG, setDAG] := createSignal<LadderDAG | null>()
  [computing, setComputing] := createSignal false
  [dictSize, setDictSize] := createSignal<number | undefined>()
  let forbid: HTMLTextAreaElement

  recompute := =>
    s := start()
    g := goal()
    unless s and g
      setLadder null
      setDAG null
      return
    console.log s, '->', g
    {depth} := ladderSearch.options = options()
    setComputing true
    queueMicrotask =>
      if depth
        setDAG ladderSearch.ladderDAG s, g, depth
      else
        setLadder ladderSearch.shortestLadder s, g
      setComputing false
  createEffect recompute

  updateForbid := =>
    setOptions {...options(), forbid: new Set forbid.value.toLowerCase().split /\s+/}
  onForbid := (word: string) =>
    forbid.value = `${word} ${forbid.value}`
    updateForbid()

  fetch wordList
  .then (response) =>
    response.text() |> await |> ladderSearch.parseDict
    setDictSize ladderSearch.dict!.length
    recompute()

  <header>
    Word Ladder Designer
  <div .input>
    from <input #start onInput={(e) => setStart e.currentTarget.value.toLowerCase()}>
    &nbsp;
    to <input #goal onInput={(e) => setGoal e.currentTarget.value.toLowerCase()}>
    &nbsp;
    <button onClick=recompute>Search
    <br/>
    dictionary <select/>
    &nbsp;
    <Show when={dictSize()} fallback='(loading)'>
      has {dictSize()} words
    <br/>
    extra words: <textarea #extra onInput={(e) => setOptions {...options(), extra: new Set e.currentTarget.value.toLowerCase().split /\s+/}}>
    &nbsp;
    forbid words: <textarea ref={forbid!} #forbid onInput=updateForbid>
    <br/>
    swaps? <input #swap type="checkbox" checked onInput={(e) => setOptions {...options(), swap: e.currentTarget.checked}}>
    &nbsp;
    inserts? <input type="checkbox" checked onInput={(e) => setOptions {...options(), insert: e.currentTarget.checked}}>
    &nbsp;
    deletes? <input type="checkbox" checked onInput={(e) => setOptions {...options(), delete: e.currentTarget.checked}}>
    <br/>
    build DAG with depth <input #depth type="number" onInput={(e) => setOptions {...options(), depth: e.currentTarget.valueAsNumber}}>
  <main>
    <ul>
      {do
        return <i>[Computing...]</i> if computing()
        if options().depth
          d := DAG()
          return <i>[No ladder]</i> unless d
          word .= start()
          g := goal()
          results := [
            <li>{word.toUpperCase()}
          ]
          until word is g
            children := d.child.get word
            if children
              word = children[0]
              results.push <li>{word.toUpperCase()}
            else
              results.push <li><i>no children?!
              break
          results
        else
          l := ladder()
          return <i>[No ladder]</i> unless l
          for each word of l
            <li>{word.toUpperCase()}
              <button .forbid onClick={[onForbid, word]}>Ã—
      }
  <footer>
    <a href="https://github.com/edemaine/word-ladder">Source code on GitHub</a>
