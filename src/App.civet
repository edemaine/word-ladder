{createEffect, createResource, createSignal, For} from 'solid-js'
{type LadderDAG, type LadderOptions, LadderSearch} from './ladder.civet'
wordList from './assets/wordlist.10000.txt'

export function App
  [start, setStart] := createSignal ''
  [goal, setGoal] := createSignal ''
  [options, setOptions] := createSignal<LadderOptions & {depth?: number}> {}
  ladderSearch .= new LadderSearch []
  [ladder, setLadder] := createSignal<string[] | null> []
  [DAG, setDAG] := createSignal<LadderDAG | null>()
  [computing, setComputing] := createSignal false

  recompute := =>
    unless start() and goal()
      setLadder null
      setDAG null
      return
    console.log start(), '->', goal()
    {depth} := ladderSearch.options = options()
    setComputing true
    queueMicrotask =>
      if depth
        setDAG ladderSearch.ladderDAG start(), goal(), depth
      else
        setLadder ladderSearch.shortestLadder start(), goal()
      setComputing false
  createEffect recompute

  fetch wordList
  .then (response) =>
    response.text() |> await |> ladderSearch.parseDict
    recompute()

  <header>
    Word Ladder Designer
  <div .input>
    from <input #start onChange={(e) => setStart e.currentTarget.value}>
    &nbsp;
    to <input #goal onChange={(e) => setGoal e.currentTarget.value}>
    <br/>
    dictionary <select/>
    &nbsp;
    extra words: <textarea #extra onChange={(e) => setOptions {...options(), extra: new Set e.currentTarget.value.split /\s+/}}>
    &nbsp;
    forbid words: <textarea #forbid onChange={(e) => setOptions {...options(), forbid: new Set e.currentTarget.value.split /\s+/}}>
    <br/>
    swaps? <input #swap type="checkbox" onInput={(e) => setOptions {...options(), swap: e.currentTarget.checked}}>
    &nbsp;
    inserts? <input type="checkbox" onInput={(e) => setOptions {...options(), insert: e.currentTarget.checked}}>
    &nbsp;
    deletes? <input type="checkbox" onInput={(e) => setOptions {...options(), delete: e.currentTarget.checked}}>
    <br/>
    build DAG with depth <input #depth type="number" onInput={(e) => setOptions {...options(), depth: e.currentTarget.valueAsNumber}}>
  <main>
    <ul>
      {do
        return <i>[Computing...]</i> if computing()
        if options().depth
          d := DAG()
          return <i>[No ladder]</i> unless d
          for each item of d
            <li>{item.toUpperCase()}
        else
          l := ladder()
          return <i>[No ladder]</i> unless l
          for each word of l
            <li>{word.toUpperCase()}
      }
  <footer>
    <a href="https://github.com/edemaine/word-ladder">Source code on GitHub</a>
