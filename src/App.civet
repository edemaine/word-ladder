{createEffect, createMemo, createResource, createSignal, For, Show} from 'solid-js'
{createStore} from 'solid-js/store'
{type LadderDAG, type LadderOptions, LadderSearch} from './ladder.civet'

wordList from '../data/wordlist.10000.txt'

export function App
  [state, setState] := createStore
    start: ''
    goal: ''
    extra: ''
    forbid: ''
    swap: true
    insert: true
    delete: true
    shortest: true
    path: []
  options := createMemo<LadderOptions> =>
    {
      state.{swap,insert}
      state.delete
      extra: new Set state.extra.toLowerCase().split(/\s+/).filter (&)
      forbid: new Set state.forbid.toLowerCase().split(/\s+/).filter (&)
    }
  ladderSearch .= new LadderSearch []
  [ladder, setLadder] := createSignal<string[] | null> []
  [DAG, setDAG] := createSignal<LadderDAG | null>()
  [computing, setComputing] := createSignal false
  [dictSize, setDictSize] := createSignal<number | undefined>()

  function loadURL
    params := new URLSearchParams window.location.search
    for key of ['start', 'goal', 'extra', 'forbid'] as const
      setState key, params.get(key) ?? ''
    for key of ['swap', 'insert', 'delete', 'shortest'] as const
      setState key, Boolean parseInt params.get(key) ?? '1', 10
  loadURL()
  window.addEventListener 'popstate', loadURL

  createEffect =>
    search .= ''
    for opt of ['start', 'goal', 'extra', 'forbid'] as const
      search += `&${opt}=${encodeURIComponent state[opt]}` if state[opt]
    for opt of ['swap', 'insert', 'delete', 'shortest'] as const
      search += `&${opt}=0` unless state[opt]
    search = `?${search[1..]}` if search
    return if search is window.location.search
    history.pushState null, 'ladder', `${window.location.pathname}${search}`

  recompute := =>
    s := state.start
    g := state.goal
    unless s and g
      setLadder null
      setDAG null
      return
    console.log s, '->', g
    {shortest} := state
    ladderSearch.options = options()
    setComputing true
    queueMicrotask =>
      if shortest
        setLadder ladderSearch.shortestLadder s, g
      else
        setDAG ladderSearch.ladderDAG s, g
      setComputing false
  createEffect recompute

  onForbid := (word: string) =>
    setState 'forbid', `${word} ${state.forbid}`

  fetch wordList
  .then (response) =>
    response.text() |> await |> ladderSearch.parseDict
    setDictSize ladderSearch.dict!.length
    recompute()

  <header>
    Word Ladder Designer
  <div .input>
    from <input #start value=state.start onInput={(e) => setState 'start', e.currentTarget.value.toLowerCase()}>
    &nbsp;
    to <input #goal value=state.goal onInput={(e) => setState 'goal', e.currentTarget.value.toLowerCase()}>
    <!--
    &nbsp;
    <button onClick=recompute>Search
    -->
    <br/>
    dictionary <select/>
    &nbsp;
    <Show when={dictSize()} fallback='(loading)'>
      has {dictSize()} words
    <br/>
    extra words: <textarea #extra value=state.extra onInput={(e) => setState 'extra', e.currentTarget.value.toLowerCase()}>
    &nbsp;
    forbid words: <textarea #forbid value=state.forbid onInput={(e) => setState 'forbid', e.currentTarget.value.toLowerCase()}>
    <br/>
    swaps? <input #swap type="checkbox" checked=state.swap onInput={(e) => setState 'swap', e.currentTarget.checked}>
    &nbsp;
    inserts? <input type="checkbox" checked=state.insert onInput={(e) => setState 'insert', e.currentTarget.checked}>
    &nbsp;
    deletes? <input type="checkbox" checked=state.delete onInput={(e) => setState 'delete', e.currentTarget.checked}>
    &nbsp;
    shortest? <input type="checkbox" checked=state.shortest onInput={(e) => setState 'shortest', e.currentTarget.checked}>
  <main>
    <ul>
      {do
        return <i>[Computing...]</i> if computing()
        if state.shortest
          l := ladder()
          return <i>[No ladder]</i> unless l
          for each word of l
            <li>{word.toUpperCase()}
              <button .forbid onClick={[onForbid, word]}>Ã—
        else
          d := DAG()
          return <i>[No ladder]</i> unless d
          word .= state.start
          g := state.goal
          results := [
            <li>{word.toUpperCase()}<sub>{d.dist.get word}
          ]
          seen := new Set<string>
          until word is g
            seen.add word
            children .= d.child.get word
            if children
              children = children.filter (child) => not seen.has child
              results.push <li>{
                for child, i of children
                  <>
                    {', ' if i}
                    <a>{child.toUpperCase()}<sub>{d.dist.get child}
              }
              if children.length
                word = children[0]
              else
                results[results.length-1] = <li><i>LOOP :-(
            else
              results.push <li><i>no children?!
              break
          results
      }
  <footer>
    <a href="https://github.com/edemaine/word-ladder">Source code on GitHub</a>
