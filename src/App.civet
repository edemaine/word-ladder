{createEffect, createResource, createSignal, For, Show} from 'solid-js'
{type LadderDAG, type LadderOptions, LadderSearch} from './ladder.civet'

wordList from '../data/wordlist.10000.txt'

export function App
  [start, setStart] := createSignal ''
  [goal, setGoal] := createSignal ''
  [options, setOptions] := createSignal<LadderOptions & {depth?: number}>
    swap: true
    insert: true
    delete: true
  ladderSearch .= new LadderSearch []
  [ladder, setLadder] := createSignal<string[] | null> []
  [DAG, setDAG] := createSignal<LadderDAG | null>()
  [computing, setComputing] := createSignal false
  [dictSize, setDictSize] := createSignal<number | undefined>()
  let extraRef: HTMLTextAreaElement, forbidRef: HTMLTextAreaElement

  function loadURL
    params := new URLSearchParams window.location.search
    setStart params.get('start')! if params.has 'start'
    setGoal params.get('goal')! if params.has 'goal'
  loadURL()
  window.addEventListener 'popstate', loadURL

  createEffect =>
    search .= ''
    search += `&start=${encodeURIComponent start()}` if start()
    search += `&goal=${encodeURIComponent goal()}` if goal()
    o := options()
    for opt of ['depth'] as const
      search += `&${opt}=${encodeURIComponent o[opt]!}` if o[opt]
    for opt of ['extra', 'forbid'] as const
      search += `&${opt}=${encodeURIComponent Array.from(o[opt]!).join ' '}` if o[opt]?.size
    for opt of ['swap', 'insert', 'delete'] as const
      search += `&${opt}=0` unless o[opt]
    search = `?${search[1..]}` if search
    return if search is window.location.search
    history.pushState null, 'ladder', `${window.location.pathname}${search}`

  recompute := =>
    s := start()
    g := goal()
    unless s and g
      setLadder null
      setDAG null
      return
    console.log s, '->', g
    {depth} := ladderSearch.options = options()
    setComputing true
    queueMicrotask =>
      if depth
        setDAG ladderSearch.ladderDAG s, g, depth
      else
        setLadder ladderSearch.shortestLadder s, g
      setComputing false
  createEffect recompute

  updateForbid := =>
    setOptions {...options(), forbidRef: new Set forbidRef.value.toLowerCase().split(/\s+/).filter (&)}
  onForbid := (word: string) =>
    forbidRef.value = `${word} ${forbidRef.value}`
    updateForbid()

  fetch wordList
  .then (response) =>
    response.text() |> await |> ladderSearch.parseDict
    setDictSize ladderSearch.dict!.length
    recompute()

  <header>
    Word Ladder Designer
  <div .input>
    from <input #start value={start()} onInput={(e) => setStart e.currentTarget.value.toLowerCase()}>
    &nbsp;
    to <input #goal value={goal()} onInput={(e) => setGoal e.currentTarget.value.toLowerCase()}>
    <!--
    &nbsp;
    <button onClick=recompute>Search
    -->
    <br/>
    dictionary <select/>
    &nbsp;
    <Show when={dictSize()} fallback='(loading)'>
      has {dictSize()} words
    <br/>
    extra words: <textarea ref={extraRef!} #extra onInput={(e) => setOptions {...options(), extra: new Set e.currentTarget.value.toLowerCase().split(/\s+/).filter (&)}}>
    &nbsp;
    forbid words: <textarea ref={forbidRef!} #forbid onInput=updateForbid>
    <br/>
    swaps? <input #swap type="checkbox" checked onInput={(e) => setOptions {...options(), swap: e.currentTarget.checked}}>
    &nbsp;
    inserts? <input type="checkbox" checked onInput={(e) => setOptions {...options(), insert: e.currentTarget.checked}}>
    &nbsp;
    deletes? <input type="checkbox" checked onInput={(e) => setOptions {...options(), delete: e.currentTarget.checked}}>
    <br/>
    build DAG with depth <input #depth type="number" onInput={(e) => setOptions {...options(), depth: e.currentTarget.valueAsNumber}}>
  <main>
    <ul>
      {do
        return <i>[Computing...]</i> if computing()
        if options().depth
          d := DAG()
          return <i>[No ladder]</i> unless d
          word .= start()
          g := goal()
          results := [
            <li>{word.toUpperCase()}
          ]
          until word is g
            children := d.child.get word
            if children
              word = children[0]
              results.push <li>{word.toUpperCase()}
            else
              results.push <li><i>no children?!
              break
          results
        else
          l := ladder()
          return <i>[No ladder]</i> unless l
          for each word of l
            <li>{word.toUpperCase()}
              <button .forbid onClick={[onForbid, word]}>Ã—
      }
  <footer>
    <a href="https://github.com/edemaine/word-ladder">Source code on GitHub</a>
