{createEffect, createMemo, createResource, createSignal, For, Show} from 'solid-js'
{createStore} from 'solid-js/store'
{type LadderDAG, type LadderOptions, LadderSearch} from './ladder.civet'

wordList from '../data/wordlist.10000.txt'

defaultState :=
  start: ''
  goal: ''
  extra: ''
  forbid: ''
  swap: true
  insert: true
  delete: true
  shortest: true

export function App
  [state, setState] := createStore {
    ...defaultState
    path: []
  }
  options := createMemo<LadderOptions> =>
    {
      state.{swap,insert}
      state.delete
      extra: new Set state.extra.toLowerCase().split(/\s+/).filter (&)
      forbid: new Set state.forbid.toLowerCase().split(/\s+/).filter (&)
    }
  ladderSearch .= new LadderSearch []
  [ladder, setLadder] := createSignal<string[] | null> []
  [DAG, setDAG] := createSignal<LadderDAG | null>()
  [computing, setComputing] := createSignal false
  [dictSize, setDictSize] := createSignal<number | undefined>()

  function loadURL
    params := new URLSearchParams window.location.search
    for key of ['start', 'goal', 'extra', 'forbid'] as const
      setState key, params.get(key) ?? defaultState[key]
    for key of ['swap', 'insert', 'delete', 'shortest'] as const
      set .= false
      if params.has key
        n .= parseInt params.get(key)!, 10
        unless isNaN n
          setState key, Boolean n
          set = true
      unless set
        setState key, defaultState[key]
  loadURL()
  window.addEventListener 'popstate', loadURL

  createEffect =>
    search .= ''
    for opt of ['start', 'goal', 'extra', 'forbid'] as const
      unless state[opt] is defaultState[opt]
        search += `&${opt}=${encodeURIComponent state[opt]}`
    for opt of ['swap', 'insert', 'delete', 'shortest'] as const
      unless state[opt] is defaultState[opt]
        search += `&${opt}=${Number state[opt]}`
    search = `?${search[1..]}` if search
    return if search is window.location.search
    history.pushState null, 'ladder', `${window.location.pathname}${search}`

  recompute := =>
    s := state.start
    g := state.goal
    unless s and g
      setLadder null
      setDAG null
      return
    console.log s, '->', g
    {shortest} := state
    ladderSearch.options = options()
    setComputing true
    queueMicrotask =>
      if shortest
        setLadder ladderSearch.shortestLadder s, g
      else
        setDAG ladderSearch.ladderDAG s, g
      setComputing false
  createEffect recompute

  swapStartGoal := =>
    {start, goal} := state
    setState 'start', goal
    setState 'goal', start

  onForbid := (word: string) =>
    setState 'forbid', `${word} ${state.forbid}`

  fetch wordList
  .then (response) =>
    response.text() |> await |> ladderSearch.parseDict
    setDictSize ladderSearch.dict!.length
    recompute()

  <header>
    Word Ladder Designer
  <div .input>
    from <input #start value=state.start onInput={(e) => setState 'start', e.currentTarget.value.toLowerCase()}>
    &nbsp;
    to <input #goal value=state.goal onInput={(e) => setState 'goal', e.currentTarget.value.toLowerCase()}>
    &nbsp;
    <button onClick=swapStartGoal>↔
    <!--
    &nbsp;
    <button onClick=recompute>Search
    -->
    <br/>
    dictionary <select/>
    &nbsp;
    <Show when={dictSize()} fallback=<b><i>(still loading)</i></b>>
      has {dictSize()} words
    <br/>
    extra words: <textarea #extra value=state.extra onInput={(e) => setState 'extra', e.currentTarget.value.toLowerCase()}>
    &nbsp;
    forbid words: <textarea #forbid value=state.forbid onInput={(e) => setState 'forbid', e.currentTarget.value.toLowerCase()}>
    <br/>
    swaps? <input #swap type="checkbox" checked=state.swap onInput={(e) => setState 'swap', e.currentTarget.checked}>
    &nbsp;
    inserts? <input type="checkbox" checked=state.insert onInput={(e) => setState 'insert', e.currentTarget.checked}>
    &nbsp;
    deletes? <input type="checkbox" checked=state.delete onInput={(e) => setState 'delete', e.currentTarget.checked}>
    &nbsp;
    shortest? <input type="checkbox" checked=state.shortest onInput={(e) => setState 'shortest', e.currentTarget.checked}>
  <main>
    <ul>
      {do
        return <i>[Computing...]</i> if computing()
        if state.shortest
          l := ladder()
          return <i>[No ladder]</i> unless l
          for each word of l
            <li>{word.toUpperCase()}
              <button .forbid onClick={[onForbid, word]}>×
        else
          d := DAG()
          return <i>[No ladder]</i> unless d
          word .= state.start
          g := state.goal
          results := []
          seen := new Set<string>
          step .= 0
          until word is g
            prefix := <>{word.toUpperCase()}<sub>{d.dist.get word}</sub> — </>
            seen.add word
            children .= d.child.get word
            if children
              children = children.filter (child) => not seen.has child
              let nextWord: string
              if children.length
                nextPath := state.path[step]
                if children.includes nextPath
                  nextWord = nextPath
                else
                  nextWord = children[0]
                  nextDist .= Infinity
                  for child of children
                    childDist := d.dist.get child
                    continue unless childDist?
                    if nextDist > childDist
                      nextWord = child
                      nextDist = childDist
              else
                results.push <li>{prefix}<i>LOOP :-(
                break
              thisStep := step
              results.push <li>{prefix}{
                for child, i of children
                  select := (e) =>
                    e.preventDefault()
                    setState 'path', thisStep, child
                    for i of [thisStep+1...state.path.length]
                      setState 'path', i, undefined
                  <>
                    {', ' if i}
                    {if child is nextWord
                      <span>{child.toUpperCase()}<sub>{d.dist.get child}
                    else
                      <a href="#" onClick={select}>{child.toUpperCase()}<sub>{d.dist.get child}
                    }
              }
              word = nextWord
              step++
            else
              results.push <li>{prefix}<i>no children?!
              break
          if word is g
            results.push <li>{g.toUpperCase()}<sub>{d.dist.get g}
          results
      }
  <footer>
    <a href="https://github.com/edemaine/word-ladder">Source code on GitHub</a>
